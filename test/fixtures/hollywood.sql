-- This schema should include everything that PostgREST needs to know about
-- in dbStructure (the "schema cache"). The goal is to make this a "real" schema
-- without too much articial objects ("items", "no_pk_table", ...) to be able to
-- use it as a nice reference in the docs at the same time.
--
-- The schema cache is currently used for the following core features:
-- * Embedding relations
-- * Calling RPCs
-- * Creating a Location header after INSERT
--
-- As such, the focus is on all kind of primary keys, foreign key relationships
-- and overloaded functions. Each object's comment describes only a few key features,
-- but may not cover all of them.

-- The world may be hidden to us ...
CREATE SCHEMA world;
-- ... but hollywood is exposed!
CREATE SCHEMA hollywood;
SET search_path TO hollywood;


-- TABLE world.persons:
-- * hidden schema
-- * simple pk
CREATE TABLE world.persons (
  PRIMARY KEY (person),
  person     INT
             GENERATED BY DEFAULT AS IDENTITY,
  last_name  TEXT,
  first_name TEXT
);


-- VIEW persons:
-- * 1 level view chain
-- * hidden base table with same name
-- * base columns from only table
-- * location header from simple pk on view
CREATE VIEW persons AS
SELECT *
  FROM world.persons;


-- TABLE films:
-- * exposed schema
-- * m2o relationship with simple key
-- * self-referencing m2o relationship with simple key
-- * location header from simple pk on table
CREATE TABLE films (
  PRIMARY KEY (film),
  film      INT
            GENERATED BY DEFAULT AS IDENTITY,
  person    INT
            CONSTRAINT director
            REFERENCES world.persons (person)
              ON UPDATE CASCADE
              ON DELETE SET NULL,
  sequel_of INT
            REFERENCES films (film)
              ON UPDATE CASCADE
              ON DELETE SET NULL,
  title     TEXT,
  year      SMALLINT,
  rating    SMALLINT,
  language  CHAR(2)
);


-- TABLE roles:
-- * m2m junction in exposed schema
-- * m2m junction with extra columns
-- * named FK (actor) in exposed table
-- * default-name FK (roles_film_fkey) in exposed table
-- * location header from compound pk on table
CREATE TABLE roles (
  PRIMARY KEY (person, film),
  person    INT
            CONSTRAINT actor
            REFERENCES world.persons (person)
              ON UPDATE CASCADE
              ON DELETE CASCADE,
  film      INT
            REFERENCES films (film)
              ON UPDATE CASCADE
              ON DELETE CASCADE,
  character TEXT
);


-- VIEW directors:
-- * 2 level view chain (V directors -> V persons -> T world.persons)
-- * exposed middle view (actors)
-- * hidden base table with different name
-- * base columns from JOIN
-- * inherited o2m relationship with simple key (films)
CREATE VIEW directors (director, last_name, first_name) AS
SELECT persons.*
  FROM films
       JOIN persons USING (person);


-- VIEW actors:
-- * 2 level view chain (V actors -> V persons -> T world.persons)
-- * exposed middle view (actors)
-- * base columns from FROM
-- * inherited m2m relationship with simple keys (films through roles)
CREATE VIEW actors (actor, last_name, first_name) AS
SELECT persons.*
  FROM persons
       JOIN roles USING (person);


-- TABLE world.competitions:
-- * compound pk
CREATE TABLE world.competitions (
  PRIMARY KEY (name, year),
  name TEXT NOT NULL,
  year SMALLINT NOT NULL
);


-- VIEW competitions:
-- * location header from compound pk on view
CREATE VIEW competitions AS
SELECT *
  FROM world.competitions;


-- TABLE world.nominations:
-- * m2m junction in hidden schema
-- * named FK (competition) in hidden table
-- * default-name FK (nominations_film_fkey) in hidden table
CREATE TABLE world.nominations (
  UNIQUE (name, year, rank),
  UNIQUE (name, year, film),
  CONSTRAINT competition FOREIGN KEY
  (name, year) REFERENCES world.competitions (name, year)
                 MATCH FULL
                 ON UPDATE CASCADE
                 ON DELETE CASCADE,
  name         TEXT,
  year         SMALLINT,
  rank         SMALLINT,
  film         INT
               REFERENCES films (film)
                 ON UPDATE CASCADE
                 ON DELETE CASCADE
);


-- VIEW nominations:
-- * m2m junction base table with same name
-- * m2m junction with compound key
-- * m2o relationship with compound key
-- * TODO?: location header without pk but unique constraint
CREATE VIEW nominations AS
SELECT *
  FROM world.nominations;


-- VIEW stats:
-- * sub query in SELECT
-- * sub query in function call in SELECT
-- * aggregate with GROUP BY
CREATE VIEW stats (film, no_of_actors, nominations, best_rank) AS
  SELECT film,
         COUNT(*) AS no_of_actors,
         COALESCE(
           (SELECT array_agg(DISTINCT name)
              FROM nominations
             WHERE nominations.film = roles.film),
           '{}'::text[]
         ) AS nominations,
         (SELECT MIN(rank)
            FROM nominations
           WHERE nominations.film = roles.film
         ) AS best_rank
    FROM roles
GROUP BY film;


-- VIEW bacons_law:
-- https://en.wikipedia.org/wiki/Six_Degrees_of_Kevin_Bacon
-- * RECURSIVE UNION
-- * TODO: inherited relationships
CREATE RECURSIVE VIEW bacons_law (person, bacon_number) AS
  SELECT person, 0
    FROM persons
   WHERE (last_name, first_name) = ('Bacon', 'Kevin')
UNION ALL
  SELECT r2.person, bacon_number + 1
    FROM bacons_law
         JOIN roles AS r1 USING (person)
         JOIN roles AS r2 USING (film);


-- TABLE world.friends:
-- * m2m junction for self-reference (persons) with simple key
-- * no location header without pk or unique constraint
CREATE TABLE world.friends (
  CONSTRAINT no_schizophrenia
    CHECK (person <> friend),
  CONSTRAINT nondirectional_unique
    EXCLUDE ( ((LEAST(person, friend), GREATEST(person, friend))::world.friends) WITH =),
  person INT
         REFERENCES world.persons (person)
           ON UPDATE CASCADE
           ON DELETE CASCADE,
  friend INT
         REFERENCES world.persons (person)
           ON UPDATE CASCADE
           ON DELETE CASCADE
);


-- VIEW world.all_friends:
-- * m2m junction without extra columns
-- * UNION to allow nondirectional joins
-- * TODO: inherited relationships with UNION
CREATE VIEW world.all_friends (person, friend) AS
SELECT person, friend
  FROM world.friends
UNION ALL
SELECT friend, person
  FROM world.friends;


-- VIEW friends:
-- * 2 level view chain (V friends -> V world.all_friends -> T world.friends)
-- * hidden middle view (world.all_friends)
CREATE VIEW friends AS
SELECT *
  FROM world.all_friends;


-- RPC circle_of_friends #1:
-- returns a list of all friends of person per
-- includes per itself by default
-- GET /rpc/circle_of_friends?per=<person>
-- GET /rpc/circle_of_friends?per=<person>&self=false
-- * STABLE
-- * RETURNS SETOF composite
-- * argument with DEFAULT value
CREATE FUNCTION circle_of_friends (per INT, self BOOLEAN DEFAULT TRUE) RETURNS SETOF world.persons
STABLE LANGUAGE SQL AS $$
  SELECT *
    FROM world.persons
   WHERE person = p
         AND self
  UNION
  SELECT persons.*
    FROM world.all_friends
   WHERE friend = p
         JOIN world.persons USING (person)
$$;


-- RPC circle_of_friends #2:
-- returns a random friend of person per
-- similar to google's "I'm feeling lucky" button
-- GET /rpc/circle_of_friends?per=<person>&btnl
-- * STABLE
-- * RETURNS composite
CREATE FUNCTION circle_of_friends (per INT, btnl TEXT) RETURNS world.persons
STABLE LANGUAGE SQL AS $$
    SELECT *
      FROM circle_of_friends(per, FALSE)
  ORDER BY RANDOM()
     LIMIT 1
$$;


-- RPC circle_of_friends #3:
-- returns a list of persons' ids who share common friends
-- GET /rpc/circle_of_friends?f=<person1>&f=<person2>
-- * STABLE
-- * RETURNS SETOF scalar
-- * only VARIADIC argument
CREATE FUNCTION circle_of_friends (VARIADIC f INT[]) RETURNS SETOF INT
STABLE LANGUAGE SQL AS $$
    SELECT person
      FROM world.all_friends
     WHERE friend = ANY(f)
  GROUP BY person
    HAVING COUNT(friend) = ARRAY_LENGTH(f)
$$;


-- RPC circle_of_friends #4:
-- returns a random peron's id who share common friends
-- similar to google's "I'm feeling lucky" button
-- GET /rpc/circle_of_friends?f=<person1>&f=<person2>&btnl
-- * STABLE
-- * RETURNS scalar
-- * VARIADIC argument among others
CREATE FUNCTION circle_of_friends (btnl TEXT, VARIADIC f INT[]) RETURNS INT
STABLE LANGUAGE SQL AS $$
    SELECT *
      FROM circle_of_friends(btnl, VARIADIC f)
  ORDER BY RANDOM()
     LIMIT 1
$$;


-- RPC circle_of_friends #5:
-- not callable helper function to insert records
-- * overloaded function with unnamed arguments
CREATE FUNCTION circle_of_friends (world.persons, world.persons[]) RETURNS INT
LANGUAGE SQL AS $$
  WITH
  inserted_person AS (
    INSERT INTO world.persons (last_name, first_name)
    SELECT $1.last_name, $1.first_name
    RETURNING person
  ),
  inserted_friends AS (
    INSERT INTO world.persons (last_name, first_name)
    SELECT unnest($2).last_name, unnest($2).first_name
    RETURNING person
  )
  INSERT INTO world.friends
  SELECT inserted_person.person, inserted_friends.person
    FROM inserted_person, inserted_friends
  ON CONFLICT DO NOTHING
  RETURNING person
$$;


-- RPC circle_of_friends #6:
-- relational insert of a circle of friends
-- POST /rcp/circle_of_friends
-- {
--   last_name: 'Doe',
--   first_name: 'John',
--   friends: [
--     { last_name: 'Doe', first_name: 'Jane' }
--   ]
-- }
-- * VOLATILE
-- * RETURNS void
CREATE FUNCTION circle_of_friends (last_name TEXT, first_name TEXT, friends world.persons[] DEFAULT '{}') RETURNS void
LANGUAGE SQL AS $$
  SELECT circle_of_friends((NULL, last_name, first_name)::world.persons, friends)
$$;


-- RPC circle_of_friends #7:
-- relational insert of a circle of friends via Prefer: params=single-object
-- * VOLATILE
-- * Prefer: params=single-object
CREATE FUNCTION circle_of_friends (JSON) RETURNS INT
LANGUAGE SQL AS $$
  SELECT circle_of_friends(
           json_populate_record(NULL::world.persons, $1),
           ARRAY[SELECT json_populate_recordset(NULL::world.persons[], $1->'friends')]
         )
$$;

{-|
Module      : PostgREST.Query.Statements
Description : PostgREST single SQL statements.

This module constructs single SQL statements that can be parametrized and prepared.

- It consumes the SqlQuery types generated by the QueryBuilder module.
- It generates the body format and some headers of the final HTTP response.
-}
module PostgREST.Query.Statements
  ( prepareWrite
  , prepareRead
  , prepareCall
  , preparePlanRows
  , ResultSet (..)
  ) where

import qualified Data.Aeson.Lens                   as L
import qualified Data.ByteString.Char8             as BS
import qualified Hasql.Decoders                    as HD
import qualified Hasql.DynamicStatements.Statement as SQL
import qualified Hasql.Statement                   as SQL

import Control.Lens ((^?))

import PostgREST.ApiRequest.Preferences
import PostgREST.MediaType              (MTVndPlanFormat (..),
                                         MediaType (..))
import PostgREST.Query.SqlFragment
import PostgREST.SchemaCache.Routine    (MediaHandler (..), Routine,
                                         funcReturnsSingle)

import Protolude

-- | Standard result set format used for all queries
data ResultSet
  = RSStandard
  { rsTableTotal :: Maybe Int64
  -- ^ count of all the table rows
  , rsQueryTotal :: Int64
  -- ^ count of the query rows
  , rsLocation   :: [(BS.ByteString, BS.ByteString)]
  -- ^ The Location header(only used for inserts) is represented as a list of strings containing
  -- variable bindings like @"k1=eq.42"@, or the empty list if there is no location header.
  , rsBody       :: BS.ByteString
  -- ^ the aggregated body of the query
  , rsGucHeaders :: Maybe BS.ByteString
  -- ^ the HTTP headers to be added to the response
  , rsGucStatus  :: Maybe Text
  -- ^ the HTTP status to be added to the response
  , rsInserted   :: Maybe Int64
  -- ^ the number of rows inserted (Only used for upserts)
  }
  | RSPlan BS.ByteString -- ^ the plan of the query


prepareWrite :: TrackedSnippet -> TrackedSnippet -> Bool -> Bool -> MediaType -> MediaHandler ->
                Maybe PreferRepresentation -> Maybe PreferResolution -> [Text] -> Bool -> (SQL.Statement () ResultSet, ByteString, [Maybe ByteString])
prepareWrite selectQuery mutateQuery isInsert isPut mt handler rep resolution pKeys prepared =
  (result, sql, params finalQuery)
 where
  result@(SQL.Statement sql _ _ _) = SQL.dynamicallyParameterized (toSnippet finalQuery) decodeIt prepared
  checkUpsert snip = if isInsert && (isPut || resolution == Just MergeDuplicates) then snip else rawSQL "''"
  pgrstInsertedF = checkUpsert $ rawSQL "nullif(current_setting('pgrst.inserted', true),'')::int"
  finalQuery = mtSnippet mt querySnippet
  querySnippet =
    rawSQL "WITH " <> sourceCTE <> rawSQL " AS (" <> mutateQuery <> rawSQL ") " <>
    rawSQL "SELECT " <>
      rawSQL "'' AS total_result_set, " <>
      rawSQL "pg_catalog.count(_postgrest_t) AS page_total, " <>
      locF <> rawSQL " AS header, " <>
      handlerF Nothing handler <> rawSQL " AS body, " <>
      responseHeadersF <> rawSQL " AS response_headers, " <>
      responseStatusF <> rawSQL " AS response_status, " <>
      pgrstInsertedF <> rawSQL " AS response_inserted " <>
    rawSQL "FROM (" <> selectF <> rawSQL ") _postgrest_t"

  locF =
    if isInsert && rep == Just HeadersOnly
      then
        rawSQL "CASE WHEN pg_catalog.count(_postgrest_t) = 1 " <>
          rawSQL "THEN coalesce(" <> locationF pKeys <> rawSQL ", " <> noLocationF <> rawSQL ") " <>
          rawSQL "ELSE " <> noLocationF <> rawSQL " " <>
        rawSQL "END"
      else noLocationF

  selectF
    -- prevent using any of the column names in ?select= when no response is returned from the CTE
    | handler == NoAgg = rawSQL "SELECT * FROM " <> sourceCTE
    | otherwise        = selectQuery

  decodeIt :: HD.Result ResultSet
  decodeIt = case mt of
    MTVndPlan{} -> planRow
    _           -> fromMaybe (RSStandard Nothing 0 mempty mempty Nothing Nothing Nothing) <$> HD.rowMaybe (standardRow False)

prepareRead :: TrackedSnippet -> TrackedSnippet -> Bool -> MediaType -> MediaHandler -> Bool -> (SQL.Statement () ResultSet, ByteString, [Maybe ByteString])
prepareRead selectQuery countQuery countTotal mt handler prepared =
  (result, sql, params finalQuery)
 where
  result@(SQL.Statement sql _ _ _) = SQL.dynamicallyParameterized (toSnippet finalQuery) decodeIt prepared
  finalQuery = mtSnippet mt querySnippet
  querySnippet =
    rawSQL "WITH " <> sourceCTE <> rawSQL " AS ( " <> selectQuery <> rawSQL " ) " <>
    countCTEF <> rawSQL " " <>
    rawSQL "SELECT " <>
      countResultF <> rawSQL " AS total_result_set, " <>
      rawSQL "pg_catalog.count(_postgrest_t) AS page_total, " <>
      handlerF Nothing handler <> rawSQL " AS body, " <>
      responseHeadersF <> rawSQL " AS response_headers, " <>
      responseStatusF <> rawSQL " AS response_status, " <>
      rawSQL "''" <> rawSQL " AS response_inserted " <>
    rawSQL "FROM ( SELECT * FROM " <> sourceCTE <> rawSQL " ) _postgrest_t"

  (countCTEF, countResultF) = countF countQuery countTotal

  decodeIt :: HD.Result ResultSet
  decodeIt = case mt of
    MTVndPlan{} -> planRow
    _           -> HD.singleRow $ standardRow True

prepareCall :: Routine -> TrackedSnippet -> TrackedSnippet -> TrackedSnippet -> Bool ->
               MediaType -> MediaHandler -> Bool ->
               (SQL.Statement () ResultSet, ByteString, [Maybe ByteString])
prepareCall rout callProcQuery selectQuery countQuery countTotal mt handler prepared =
  (result, sql, params finalQuery)
  where
    result@(SQL.Statement sql _ _ _) = SQL.dynamicallyParameterized (toSnippet finalQuery) decodeIt prepared
    finalQuery = mtSnippet mt querySnippet
    querySnippet =
      rawSQL "WITH " <> sourceCTE <> rawSQL " AS (" <> callProcQuery <> rawSQL ") " <>
      countCTEF <>
      rawSQL "SELECT " <>
        countResultF <> rawSQL " AS total_result_set, " <>
        (if funcReturnsSingle rout
          then rawSQL "1"
          else rawSQL "pg_catalog.count(_postgrest_t)") <> rawSQL " AS page_total, " <>
        handlerF (Just rout) handler <> rawSQL " AS body, " <>
        responseHeadersF <> rawSQL " AS response_headers, " <>
        responseStatusF <> rawSQL " AS response_status, " <>
        rawSQL "''" <> rawSQL " AS response_inserted " <>
      rawSQL "FROM (" <> selectQuery <> rawSQL ") _postgrest_t"

    (countCTEF, countResultF) = countF countQuery countTotal

    decodeIt :: HD.Result ResultSet
    decodeIt = case mt of
      MTVndPlan{} -> planRow
      _           -> fromMaybe (RSStandard (Just 0) 0 mempty mempty Nothing Nothing Nothing) <$> HD.rowMaybe (standardRow True)

preparePlanRows :: TrackedSnippet -> Bool -> SQL.Statement () (Maybe Int64)
preparePlanRows countQuery =
  SQL.dynamicallyParameterized (toSnippet explainSnippet) decodeIt
  where
    explainSnippet = explainF PlanJSON mempty countQuery
    decodeIt :: HD.Result (Maybe Int64)
    decodeIt =
      let row = HD.singleRow $ column HD.bytea in
      (^? L.nth 0 . L.key "Plan" .  L.key "Plan Rows" . L._Integral) <$> row

standardRow :: Bool -> HD.Row ResultSet
standardRow noLocation =
  RSStandard <$> nullableColumn HD.int8 <*> column HD.int8
             <*> (if noLocation then pure mempty else fmap splitKeyValue <$> arrayColumn HD.bytea)
             <*> (fromMaybe mempty <$> nullableColumn HD.bytea)
             <*> nullableColumn HD.bytea
             <*> nullableColumn HD.text
             <*> nullableColumn HD.int8
  where
    splitKeyValue :: ByteString -> (ByteString, ByteString)
    splitKeyValue kv =
      let (k, v) = BS.break (== '=') kv in
      (k, BS.tail v)

mtSnippet :: MediaType -> TrackedSnippet -> TrackedSnippet
mtSnippet mediaType sqlSnippet = case mediaType of
  MTVndPlan _ fmt opts -> explainF fmt opts sqlSnippet
  _                    -> sqlSnippet

-- | We use rowList because when doing EXPLAIN (FORMAT TEXT), the result comes as many rows. FORMAT JSON comes as one.
planRow :: HD.Result ResultSet
planRow = RSPlan . BS.unlines <$> HD.rowList (column HD.bytea)

column :: HD.Value a -> HD.Row a
column = HD.column . HD.nonNullable

nullableColumn :: HD.Value a -> HD.Row (Maybe a)
nullableColumn = HD.column . HD.nullable

arrayColumn :: HD.Value a -> HD.Row [a]
arrayColumn = column . HD.listArray . HD.nonNullable
